<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2023/03/29/18-22-38/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo clean &amp;&amp; hexo g &amp;&amp; hexo d </span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <tags>
        <tag>-【杂谈】博客</tag>
      </tags>
  </entry>
  <entry>
    <title>第一篇博客，聊聊这个博客本身</title>
    <url>/2023/03/29/20-26-12/</url>
    <content><![CDATA[<p>算了算，自己做开发也快三年了。<span id="more"></span>平时工作中也积累的不少东西，但是一直没有很好的记录这些经验。</p>
<p>自从换了电脑之后，我开始有了用markdown写一些经验分享或者工作记录的习惯。平时写技术预研的文档，或者设计文档，甚至是交付的说明文档，都开始使用markdown。这些文档逐渐变多之后，如何管理就成了一个问题。</p>
<p>为了解决文档的管理问题，我就建了一个博客。</p>
<h2 id="还有更多的想法么？"><a href="#还有更多的想法么？" class="headerlink" title="还有更多的想法么？"></a>还有更多的想法么？</h2><p>首先，作为技术人员，留存自己的经验是很重要的。一个人的工作经验就体现在这。程序员的工作很多时候是琐碎且非常细节的，单凭人脑的记忆，绝大多数时候都会出错。</p>
<p>而且，工作毕竟是需求导向，获取新的知识只是为了解决当前的问题。但想要提高，就需要人主动去深入研究。所以我觉得，写博客的过程也是复习并提高的过程，对技术成长明显是有积极意义的。</p>
<p>另外，很多开发人员遇到问题，都会通过搜索引擎去搜索问题的解决方案。随着技术的更新，已经出现了相当多的过时答案。网络上的资料良莠不齐，会给后来人造成各种困难。我写这个博客也是为了记录自己真实的情况，真实的解决方案，希望能提供一些正确的答案。</p>
<h2 id="博客的内容会有哪些？"><a href="#博客的内容会有哪些？" class="headerlink" title="博客的内容会有哪些？"></a>博客的内容会有哪些？</h2><p>我初步考虑，是打算分三部分：生活、工作、杂谈。</p>
<p>生活就是记录一些生活中小事，可能绝大多数是做饭和健身相关？这会是类似日记一样的东西。</p>
<p>工作主要是技术文档了。更多的会是工作上的技术文档，我脱敏之后放到博客作为副本。还有些工作上遇到的问题，我尽量记录下来，把最终的解决方案也列出来，提供一些有价值的东西。当然，为了提高阅读量，我应该会单独列一个索引词的玩意儿，放在每篇文章的最前边。</p>
<p>至于杂谈，就是一些思考和规划，也有可能是投资计划之类的。不能归到生活和工作的，就都会丢到杂谈这一栏中，比如现在这第一篇博客。</p>
<h2 id="后续规划？"><a href="#后续规划？" class="headerlink" title="后续规划？"></a>后续规划？</h2><p>我平时使用的网名是涂蓝，以后在各种社交网站或者平台我应该都会统一使用这个名字。</p>
<p>技术人员或多或少都会有个技术梦。我希望后续能参与一些开源项目，逐步提高自己吧。</p>
<p>这次建博客，正好是我第一次向Spring Cloud Gateway提了一个issue，也是我第一次在github上提issue。很幸运，我提的issue被官方认证为一个确实的缺陷。不过本来我是想提PR的，可惜被一个阿里的哥们抢了。</p>
<p>这也让我突然意识到，自己已经可以参与到更大的平台中了。和我直属领导聊天时，他说一个技术人员能够去挑开源项目的刺，才说明他确实入门了。我深以为然。</p>
]]></content>
      <tags>
        <tag>-【杂谈】博客</tag>
      </tags>
  </entry>
  <entry>
    <title>Java反射调用的优化</title>
    <url>/2023/05/04/10-44-04/</url>
    <content><![CDATA[<p>effective java中曾言，避免反射的最好方式是定义接口。但反射是orm框架中不得不使用的能力，这次对反射的操作做了一次性能优化。</p>
<span id="more"></span>

<h2 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h2><p>在公司内部的缓存框架中，需要实现类似数据库的能力：比如主键、索引，还有条件查询等。</p>
<p>这些能力不可避免的需要从一个对象中，通过反射的方式来取参数的值。且目前没有办法通过定义接口的方式来优化。</p>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><p>以前的方式大多是建立Method对象的缓存，但是在查阅资料之后，我使用了一个新的方式。</p>
<p>这里我先给出一个原本的实现: </p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">  private static final Map&lt;String, Method&gt; methodsCache = new ConcurrentHashMap&lt;&gt;(256);</span><br><span class="line"></span><br><span class="line">/**</span><br><span class="line">   * 获取Object对象中指定属性的值。</span><br><span class="line">   * @param instance instance</span><br><span class="line">   * @param fieldName fieldName</span><br><span class="line">   * @return Object</span><br><span class="line">   */</span><br><span class="line">  public static Object getFieldValue(Class&lt;?&gt; clazz, Object instance, String fieldName) &#123;</span><br><span class="line">      Method method = findMethod(clazz, fieldName);</span><br><span class="line">      if (!Objects.isNull(method)) &#123;</span><br><span class="line">          try &#123;</span><br><span class="line">              return method.invoke(instance);</span><br><span class="line">          &#125; catch (IllegalAccessException | InvocationTargetException e) &#123;</span><br><span class="line">              throw new RuntimeException(e);</span><br><span class="line">          &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br><span class="line">  </span><br><span class="line">  private static Method findMethod(Class&lt;?&gt; clazz, String fieldName) &#123;</span><br><span class="line">      String methodName = &quot;get&quot; + changeFirstCharacterCase(fieldName, true);</span><br><span class="line">      // 优先从缓存获取</span><br><span class="line">      Method method = methodsCache.get(clazz.getName() + &quot;#&quot; + methodName);</span><br><span class="line">      if (!Objects.isNull(method)) &#123;</span><br><span class="line">          return method;</span><br><span class="line">      &#125;</span><br><span class="line">      // 缓存中未找到，从clazz中获取</span><br><span class="line">      try &#123;</span><br><span class="line">          method =  clazz.getMethod(methodName);</span><br><span class="line">          methodsCache.put(clazz.getName() + &quot;#&quot; + methodName, method);</span><br><span class="line">          return method;</span><br><span class="line">      &#125; catch (NoSuchMethodException e) &#123;</span><br><span class="line">          logger.error(&quot;在&#123;&#125;中未找到名为&#123;&#125;的方法名。&quot;, clazz.getName(), methodName);</span><br><span class="line">      &#125; catch (Exception e) &#123;</span><br><span class="line">          logger.error(e.getMessage(), e);</span><br><span class="line">      &#125;</span><br><span class="line">      return null;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>这逻辑不难理解，缓存了Method对象，避免每次都要进行查找。一般来说这可以很大程度的提升性能。</p>
<p>不过我随后进行了jmh的测试，发现了一些问题。</p>
<table>
<thead>
<tr>
<th>Benchmark</th>
<th>Mode</th>
<th>Cnt</th>
<th>Score</th>
<th>Score</th>
<th>Units</th>
</tr>
</thead>
<tbody><tr>
<td>testNormal</td>
<td>avgt</td>
<td>10</td>
<td>0.338</td>
<td>±   0.003</td>
<td>ns&#x2F;op</td>
</tr>
<tr>
<td>testRef</td>
<td>avgt</td>
<td>10</td>
<td>4.423</td>
<td>±   0.174</td>
<td>ns&#x2F;op</td>
</tr>
<tr>
<td>testRefBuild</td>
<td>avgt</td>
<td>10</td>
<td>181.405</td>
<td>±  21.063</td>
<td>ns&#x2F;op</td>
</tr>
</tbody></table>
<p>表格中，第一行数据是通过get方法取值；第二行是通过从缓存中获取Method然后调用取值；第三行是构建Method方法并取值。</p>
<p>不难看出：哪怕是通过缓存的方式来取值，也会导致性能下降大约十倍。</p>
<p>在查阅资料时，我发现了这篇文章：</p>
<p>[1]: <a href="https://dzone.com/articles/java-reflection-but-faster">https://dzone.com/articles/java-reflection-but-faster</a>	“java-reflection-but-faster”</p>
<p>这里提供了一个思路：通过LambdaMetafactory构建lambda表达式，在构建的lambda表达式中调用对应的方法。</p>
<p>最后的实现如下</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 对象访问器</span><br><span class="line"> *</span><br><span class="line"> * @author daizheli</span><br><span class="line"> * @since 4.2.0 2023/4/13 </span><br><span class="line"> */</span><br><span class="line">public class ObjGetter &#123;</span><br><span class="line"></span><br><span class="line">    private final Function getterFunction;</span><br><span class="line"></span><br><span class="line">    public ObjGetter(Method method) &#123;</span><br><span class="line">        MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">        try &#123;</span><br><span class="line">            MethodHandle methodHandle = lookup.unreflect(method);</span><br><span class="line">            CallSite site = LambdaMetafactory.metafactory(lookup, &quot;apply&quot;, MethodType.methodType(Function.class),</span><br><span class="line">                MethodType.methodType(Object.class, Object.class), methodHandle, methodHandle.type());</span><br><span class="line">            getterFunction = (Function) site.getTarget().invokeExact();</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public Object executeGetter(Object bean) &#123;</span><br><span class="line">        return getterFunction.apply(bean);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">/**</span><br><span class="line"> * 对象设置器</span><br><span class="line"> *</span><br><span class="line"> * @author daizheli</span><br><span class="line"> * @since 4.2.0 2023/4/13 </span><br><span class="line"> */</span><br><span class="line">public class ObjSetter &#123;</span><br><span class="line"></span><br><span class="line">    private final BiConsumer function;</span><br><span class="line"></span><br><span class="line">    public ObjSetter(Method method) &#123;</span><br><span class="line">        MethodHandles.Lookup lookup = MethodHandles.lookup();</span><br><span class="line">        try &#123;</span><br><span class="line">            MethodHandle methodHandle = lookup.unreflect(method);</span><br><span class="line">            CallSite site = LambdaMetafactory.metafactory(lookup, &quot;accept&quot;, MethodType.methodType(BiConsumer.class),</span><br><span class="line">                MethodType.methodType(void.class, Object.class, Object.class), methodHandle, methodHandle.type());</span><br><span class="line">            function = (BiConsumer) site.getTarget().invokeExact();</span><br><span class="line">        &#125; catch (Throwable e) &#123;</span><br><span class="line">            throw new RuntimeException(e);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    public void executeSetter(Object bean, Object value) &#123;</span><br><span class="line">        function.accept(bean, value);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>也跑了一下jmh，测试结果是</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">Benchmark                           Mode  Cnt      Score     Error  Units</span><br><span class="line">ObjGetterBatchTest.testLambda       avgt   10      0.692 ±   0.037  ns/op</span><br><span class="line">ObjGetterBatchTest.testLambdaBuild  avgt   10  25439.081 ± 956.824  ns/op</span><br><span class="line">ObjGetterBatchTest.testNormal       avgt   10      0.338 ±   0.003  ns/op</span><br><span class="line">ObjGetterBatchTest.testRef          avgt   10      4.423 ±   0.174  ns/op</span><br><span class="line">ObjGetterBatchTest.testRefBuild     avgt   10    181.405 ±  21.063  ns/op</span><br></pre></td></tr></table></figure>

<p>构建的速度有明显下降，但是每次调用的速度也有明显的提升。</p>
<p>在我们内部的场景下，会有启动时从数据库加载数据创建索引的步骤，因此启动时就会构建好这部分缓存，从而提高运行时的速度。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>每次反射都去查询Method是不可接受的。在缓存的基础上，通过MethodHandles其实可以提高一部分调用的性能。</p>
<p>但是综合考虑之后，还是使用LambdaMetafactory在运行时构建lambda表达式更适合当前的场景。</p>
<p>可惜的是LambdaMetafactory的案例和解析在中文网站上几乎找不到，哪怕是英文资料也很少。</p>
]]></content>
      <tags>
        <tag>【工作】性能调优</tag>
      </tags>
  </entry>
</search>
